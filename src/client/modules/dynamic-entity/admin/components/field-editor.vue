<template lang="pug">
include ../../../ui/templates/buttons.pug

div
    v-card
        v-card-text
            Form(:field_config="form_config", v-model="form_data", ref="form")
        v-card-actions
            v-spacer
            +btn_save()(@click="saveField()")
            v-spacer
    v-dialog(v-model="type_change_modal_open")
        v-card
            v-card-title Field type has changed
            v-card-text
                div Changing field type may result in corrupting or losing its data for existing entities
                div Are you sure you want to change the type?
            v-card-actions
                v-btn(color="primary")
                    +icon("ok")
                    | OK
                v-btn(color="secondary")
                    +icon("cancel")
                    | Cancel
</template>

<script lang="ts">
import { Component, Prop, Vue, Watch } from "nuxt-property-decorator";
import _ from "client/helpers/lodash";
import { EntityFieldType } from "client/modules/dynamic-entity/types";
import { FieldType } from "common/core/types/field-type-enum";
import { FormConfig, FormFieldTypeNameMap } from "client/types/editor";
import { PlainObject } from "client/types/basic";
import { ClientStorage } from "client/core/components/storage/client-storage";
import { UserAction } from "common/modules/auth/types/user-action";
import { DynamicEntity } from "client/modules/dynamic-entity/domains/dynamic-entity";
import Form from "client/modules/ui/components/form.vue";

@Component({})
export default class AdminDynamicEntityFieldEditor extends Vue {
    /**
     * Props
     */
    @Prop()
    value: EntityFieldType;

    /**
     * Variables
     */
    form_config: FormConfig = {};
    form_data: EntityFieldType = {} as any;
    type_change_modal_open: boolean = false;
    type_change_confirmed: boolean = false;

    readonly FIELD_OPTIONS: { [key: number]: string[] } = {
        [FieldType.string]: ["length"],
    };

    /**
     * Hooks
     */
    beforeMount() {
        if (!this.value.type) {
            this.value.type = FieldType.string;
        }
        _.assign(this.form_data, this.value);
        this.rebuildFormConfig();
    }

    /**
     * Watchers
     */
    @Watch("form_data.type")
    onTypeChange(new_value:FieldType, old_value: FieldType) {
        if (this.form_config.default) {
            this.form_config.default.type = this.form_data.type;
            if (typeof old_value !== "undefined" && new_value !== old_value) {
                this.form_data.default = undefined;
                this.rebuildFormConfig();
            }
        }

        switch(new_value) {
            case FieldType.string:
                break;
            default:
                this.form_data.length = null;
                break;
        }
    }

    @Watch("form_data.multivalued")
    onMultivaluedChanged() {
        this.rebuildFormConfig();
    }

    /**
     * Handlers
     */
    saveField() {
        if (!(this.$refs["form"] as Form).isValid()) {
            return;
        }
        const data = _.cloneDeep(this.form_data);
        data.default = typeof data.default !== "undefined" ? data.default.toString() : "";
        if (data.required && !data.default) {
            ClientStorage.getInstance().getStore().showError("Required fields must have default value!");
            return;
        }

        if (data.name !== this.value.name && !data.old_name) {
            data.old_name = this.value.name;
        }

        this.$emit("input", data);
    }

    /**
     * Methods
     */
    private rebuildFormConfig() {
        this.form_config = {
            type: {
                type: FieldType.select,
                options: FormFieldTypeNameMap,
                name: "Field type",
                required: true,
                hint: "Field type determines what kind of data will be stored in it",
            },
            name: {
                type: FieldType.string,
                name: "Field name (internal)",
                required: true,
                maxlength: 255,
                minlength: 3,
                custom_validator: (value: string): boolean => {
                    return value && !!value.match(/[\w_]+/);
                },
            },
            title: {
                type: FieldType.string,
                name: "Field title (UI display)",
                required: false,
                maxlength: 255,
                minlength: 3,
            },
            form_title: {
                type: FieldType.string,
                name: "Field title (in forms)",
                required: false,
                hint: "This is the name of the field that will show in autogenerated forms for this entity",
            },
            required: {
                type: FieldType.switch,
                name: "Field is required",
                required: false,
                hint: "Required fields have to specify non-empty value for this field",
            },
            multivalued: {
                type: FieldType.switch,
                name: "Field is multivalued",
                required: false,
                hint: "Multivalued fields can contain multiple values",
            },
            unique: {
                type: FieldType.switch,
                name: "Field is unique",
                required: false,
                hint: "Unique fields will contain unique value for the element",
            },
        };

        const custom_field_options = this.FIELD_OPTIONS[this.form_data.type];
        if (custom_field_options) {
            _.each(custom_field_options, (option: string) => {
                switch (option) {
                    case "length":
                        this.form_config.length = {
                            type: FieldType.number,
                            name: "Field length",
                            required: false,
                            hint: "Max length for this field (only viable for some types)",
                        };
                        break;
                }
            });
        }

        if (!this.form_data.multivalued) {
            this.form_config.default = {
                type: this.form_data.type,
                required: false,
                name: "Default value",
                hint: "This is the field value that will be assigned to all new elements.",
                custom_validator: (value: string): boolean | string => {
                    let result: boolean | string = true;
                    if (this.form_data.required && typeof value === "undefined") {
                        result = "Required fields must specify default value";
                    }

                    return result;
                },
            };
        }

        const user_permissions = ClientStorage.getInstance().getStore().getUserPermissions();
        if (user_permissions.can(UserAction.Update, new DynamicEntity(), "system_fields")) {
            this.form_config.system = {
                type: FieldType.switch,
                name: "System field",
                required: false,
                hint: "System fields are used for internal purposes and should not be modified",
            };
        }
    }
}
</script>
